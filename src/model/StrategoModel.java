package model;

import java.util.Objects;
import java.util.Observable;

import network.StrategoMessage;
import network.StrategoPieceBattle;
import network.StrategoPieceUpdate;
import view.Piece;

/**
 * Model for the Stratego game. Holds a representation of the game board
 * including the game pieces and their locations, and provides various methods
 * for interacting with the pieces and the board.
 * 
 * @author Jesse Chen, Parker Jones, Emily Pencek, Yosef Jacobson
 *
 */
public class StrategoModel extends Observable {

    public static final int ROWS = 10;
    public static final int COLS = 10;

    private Piece[] board;

    /**
     * Constructor. Initializes the board array.
     */
    public StrategoModel() {
        board = new Piece[ROWS * COLS];
    }

    private int getIndex(Loc loc) {
        return loc.getRow() * ROWS + loc.getCol();
    }

    /**
     * Checks @param loc to see if it represents a valid location on the board
     * 
     * @param loc Location input.
     * @return true if loc is valid, else false
     */
    public boolean inBounds(Loc loc) {
        if (loc == null)
            return false;
        int row = loc.getRow();
        int col = loc.getCol();
        if (row < 0 || row >= ROWS)
            return false;
        return col >= 0 && col < COLS;
    }

    /**
     * Changes the piece inside the tile at the specified coordinate.
     *
     * @param piece The piece to be set
     * @param loc   The location where piece is to be set
     * @return message The piece update message caused by setting this piece, or
     *         null if at least one of the parameters is invalid.
     */
    public StrategoPieceUpdate setPiece(Piece piece, Loc loc) {
        StrategoPieceUpdate message = null;
        if (!inBounds(loc))
            return null;
        if (piece != null && Objects.equals(piece.getLocation(), loc))
            return null;
        int index = getIndex(loc);
        if (board[index] != null)
            board[index].setLocation(null);
        board[getIndex(loc)] = piece;
        setChanged();
        if (piece != null) {
            Loc from = piece.getLocation();
            piece.setLocation(loc);
            if (from == null) {
                // Place piece
                message = new StrategoPieceUpdate(loc, piece.getPieceType(), piece.getTeam());
            } else {
                // Move piece
                board[getIndex(from)] = null;
                message = new StrategoPieceUpdate(from, loc, piece.getTeam());
            }
            notifyObservers(message);
        } else {
            // Remove piece
            message = new StrategoPieceUpdate(loc);
            notifyObservers(message);
        }
        return message;
    }

    /**
     * Apply the changes from a piece update message to this model.
     *
     * @param msg Piece update message generated by {@link #setPiece(Piece, Loc)}
     */
    public void processUpdate(StrategoMessage msg) {
        if (msg.isPieceUpdate()) {
            StrategoPieceUpdate update = (StrategoPieceUpdate) msg;
            if (update instanceof StrategoPieceBattle) {
                reveal(getPiece(update.getFrom()), getPiece(update.getTo()), ((StrategoPieceBattle) msg).isTie());
            } else {
                if (update.isPlacement()) {
                    Piece piece = new Piece(update.getPieceType(), update.getTeam(), false);
                    setPiece(piece, update.getTo());
                } else if (update.isMove()) {
                    setPiece(getPiece(update.getFrom()), update.getTo());
                } else if (update.isRemove()) {
                    setPiece(null, update.getFrom());
                }
            }
        } else {
            setChanged();
            notifyObservers(msg);
        }
    }

    /**
     * Gets the Piece object at the location specified by the Loc object.
     * 
     * @param loc The Loc object that specifies the coordinates.
     * @return the Piece object at the location specified by the Loc object
     */
    public Piece getPiece(Loc loc) {
        if (!inBounds(loc))
            return null;
        return board[getIndex(loc)];
    }

    /**
     * Deletes the piece inside the box at the specified coordinate.
     * 
     * @param loc Location of piece to remove.
     */
    public void removePiece(Loc loc) {
        setPiece(null, loc);
    }

    /**
     * Deletes the piece from the board.
     * 
     * @param piece The piece to remove.
     */
    public void removePiece(Piece piece) {
        removePiece(piece.getLocation());
    }

    /**
     * Reveals the pieces @param p1 and @param p2, making each piece visible to the
     * other player.
     * 
     * @param p1  Piece 1 to reveal
     * @param p2  Piece 2 to reveal
     * @param tie True if the pieces are equal, false if not.
     */
    public void reveal(Piece p1, Piece p2, boolean tie) {
        p1.setRevealed(true);
        p2.setRevealed(true);
        setChanged();
        notifyObservers(new StrategoPieceBattle(p1.getLocation(), p2.getLocation(), tie));
    }

    /**
     * Checks if @param team has lost the game by iterating over the board and
     * checking what pieces they have.
     * 
     * @param team False for red, true for blue.
     * @return true if team no longer has their flag or any movable pieces, else
     *         false
     */
    public boolean isGameOver(boolean team) {
        boolean hasFlag = false;
        boolean hasMoveablePiece = false;

        for (int i = 0; i < board.length; i++) {
            Piece current = board[i];
            if (current != null && current.getTeam() == team) {
                if (current.getPieceType() == PieceType.FLAG) {
                    hasFlag = true;
                } else if (current.getPieceType() != PieceType.BOMB) {
                    hasMoveablePiece = true;
                }
            }
        }
        return (!hasFlag || !hasMoveablePiece);
    }
}
